const mongoose = require('mongoose');
const path = require('path');
const dotenv = require('dotenv');

// Load env vars
dotenv.config({ path: path.join(__dirname, '.env') });

const StudentFee = require('./models/StudentFee');
const FeeHead = require('./models/FeeHead');
const Student = require('./models/Student');
const User = require('./models/User');
const Institution = require('./models/Institution');
const FeeStructure = require('./models/FeeStructure');
const Class = require('./models/Class');
const Section = require('./models/Section');
const Admission = require('./models/Admission');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/sgceducation');
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

const cleanupDuplicates = async () => {
  await connectDB();

  try {
    console.log('Scanning for duplicates to cleanup...');
    const students = await Student.find({}, '_id user');
    let totalDeleted = 0;
    
    for (const student of students) {
      const fees = await StudentFee.find({ student: student._id }); // Fetch all, active or not? better verify all.
      
      const headMap = {};
      fees.forEach(f => {
         const key = f.feeHead ? f.feeHead.toString() : 'unknown';
         if (!headMap[key]) headMap[key] = [];
         headMap[key].push(f);
      });
      
      for (const [headId, feeList] of Object.entries(headMap)) {
         if (feeList.length > 1) {
            // Check for duplicates based on VOUCHER MONTH/YEAR
            // Group by Voucher Month/Year
            const voucherMap = {};
            
            feeList.forEach(f => {
               if (f.vouchers && f.vouchers.length > 0) {
                  f.vouchers.forEach(v => {
                     const vKey = `${v.year}-${v.month}`;
                     if (!voucherMap[vKey]) voucherMap[vKey] = [];
                     // Check if this fee is already in this bucket (array of vouchers in one fee?)
                     // If fee has multiple vouchers, it might be in multiple buckets.
                     // But we want to see if MULTIPLE FEES cover the SAME month.
                     if (!voucherMap[vKey].includes(f)) {
                        voucherMap[vKey].push(f);
                     }
                  });
               }
            });
            
            // Analyze buckets
            for (const [vKey, feesInBucket] of Object.entries(voucherMap)) {
               if (feesInBucket.length > 1) {
                  // DUPLICATES FOUND for this Month!
                  console.log(`\nDuplicate Fees for User ${student._id}, Head ${headId}, Month ${vKey}: ${feesInBucket.length} records.`);
                  
                  // Sort: Prefer fees with payment, then older creation?
                  // If generated by bug, all have 0 payment.
                  feesInBucket.sort((a, b) => b.paidAmount - a.paidAmount); 
                  
                  // Keep [0]. Delete [1..n].
                  const toKeep = feesInBucket[0];
                  const toDelete = feesInBucket.slice(1);
                  
                  console.log(`  Keeping ID: ${toKeep._id} (Paid: ${toKeep.paidAmount})`);
                  
                  for (const del of toDelete) {
                     if (del.paidAmount > 0) {
                        console.log(`  WARNING: Deleting record with PAYMENT! ID: ${del._id} Amount: ${del.paidAmount}`);
                        // Skip deleting if it has payment?
                        // But duplicate payment record is bad too.
                        // Assuming bug created 0-payment duplicates.
                        continue; 
                     }
                     console.log(`  Deleting ID: ${del._id} (Paid: ${del.paidAmount})`);
                     await StudentFee.findByIdAndDelete(del._id);
                     totalDeleted++;
                  }
               }
            }
         }
      }
    }
    console.log(`\nCleanup complete. Deleted/Fixes: ${totalDeleted}`);

  } catch (err) {
    console.error(err);
  } finally {
    await mongoose.disconnect();
  }
};

cleanupDuplicates();
